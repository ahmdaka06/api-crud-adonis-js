/**
 * @module compiler/main
 */
/**
 * indicative-compiler
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { ParsedSchema } from 'indicative-parser';
import { ConsumerFn, ArrayWrapper } from '../Contracts';
/**
 * Tree walker is an agnostic implementation to walk over the parsed schema
 * tree generated by `indicative-parser`.
 *
 * The consumer of the code can define a function to consumer the tree nodes and
 * define another function to wrap the children of an array node.
 *
 * ## Why wrap array children?
 * Since the length of an array is unknown, until we receive the data at
 * runtime, we need a parent function (aka wrapper), that can execute
 * the child validations as per the length of the array.
 *
 * ```js
 * function consumerFn (
 *   field: string,
 *   rules: ParsedRule[],
 *   dotPath: string[],
 *   pointer: string,
 * ) {
 * }
 *
 * function arrayWrapper (
 *   index: string,
 *   field: string,
 *   children: ReturnType<consumerFn>[],
 *   dotPath: string[],
 * ) {
 * }
 *
 * new TreeWalker(consumerFn, arrayWrapper).walk(parsedSchema)
 * ```
 */
export declare class TreeWalker<T extends any = any, U extends any = any> {
    private consumerFn;
    private arrayWrapper;
    constructor(consumerFn: ConsumerFn<T>, arrayWrapper: ArrayWrapper<T, U>);
    /**
     * Processes the literal node inside schema tree
     */
    private processLiteralNode;
    /**
     * Process the object node inside the parsed. All children are parsed
     * recursively
     */
    private processObjectNode;
    /**
     * Process the array node of the schema tree. This method will call
     * the `arrayWrapper` function and passes all array children to it.
     */
    private processArrayNode;
    /**
     * Walks the schema tree and invokes the `consumerFn` for each node.
     * The output of the consumer is collected and returned back as an
     * array.
     */
    walk(schema: ParsedSchema, dotPath?: string[], arrayPath?: string[]): (T | U)[];
}
